# -*- coding: utf-8 -*-
"""ApproxTSP

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13G9CWVtlbQv-Yxw9vnVmb0z2jgO-WtSQ
"""

import os
import sys
import numpy as np

def dfs(visited, graph, node):  #function for depth first search
  if node not in visited:
    #print(node)
    visited.append(node)
    for neighbour in graph[node]:
      dfs(visited, graph, neighbour)

# function to choose the next node (among candidates) to be attached to partial tree
def NextNode(key, MST_inclusion):
  V = len(key)
  value_min = sys.maxsize
  index_minimum = -1
  for v in range(V):                                    # finding the cheapest node (among remaining nodes) to attach to partial tree
      if not MST_inclusion[v] and key[v] < value_min:
          value_min = key[v]
          index_minimum = v
  return index_minimum

# MST construction in the form of node parent using Prim's algo
def BuildMST(graph, pi):
  V = len(pi)
  key = [sys.maxsize] * V
  MST_inclusion = [False] * V
  key[0] = 0
  pi[0] = -1
  for _ in range(V - 1):
      u = NextNode(key, MST_inclusion)
      MST_inclusion[u] = True
      for v in range(V):                                                    # finding cheapest neighbor to attach to the latest added node
          if graph[u][v] and not MST_inclusion[v] and graph[u][v] < key[v]:
              pi[v] = u                                                     # parent node of neighbor is the newly attached node
              key[v] = graph[u][v]                                          # cost of attaching candidate



# MST construction
def PreOrderRoute(pi):
  V = len(pi)
  mst_graph = [[] for _ in range(V)]                # MST in the form of an adjacency matrix
  for i in range(1,V):
    mst_graph[pi[i]].append(i)
    mst_graph[i].append(pi[i])
  #print(mst_graph)

  visited = [] # List of visited nodes in the MST traversal without repetition
  dfs(visited, mst_graph, 0)
  visited.append(0)
  return(visited)




# TSP approx path function
def tspApproximation(graph):
  V = graph.shape[0]

  pi = [0] * V

  root = 0  # root node

  BuildMST(graph, pi) # MST construction

  H = PreOrderRoute(pi) # preorder path of the MST

  cost = 0
  for i in range(len(H)-1):
      cost += graph[H[i]][H[i+1]] # cost of approx path

  print("Sum of path:", cost)
  print("Path: ",H)

# =============================================================================
# def ApproxTSP(filename):
#   f = open(filename, 'r')
#   Lines = f.readlines()
# 
#   coords = []
#   i=0
#   for line in Lines:
#     words = line.split()
#     if len(words)==3: coords.append(np.asarray(words[1:],dtype=float))
#   coords = np.asarray(coords)
# 
#   V = coords.shape[0]
#   graph = np.zeros((V,V))         # representing graph as an adjacency matrix
#   for i in range(V):
#     for j in range(i+1,V):
#       graph[i,j] = int(np.linalg.norm(coords[i]-coords[j]))
#       graph[j,i] = graph[i,j]
#   print(filename)
#   tspApproximation(graph)
# 
# for filename in os.listdir()[2:-1]:
#   ApproxTSP(filename)
# =============================================================================

# if __name__ == "__main__":

#     # Example graph represented as an adjacency matrix
#     graph = [
#         [0, 3, 1, 6, 0, 0],
#         [3, 0, 5, 0, 3, 0],
#         [1, 5, 0, 5, 6, 4],
#         [6, 0, 5, 0, 0, 2],
#         [0, 3, 6, 0, 0, 6],
#         [0, 0, 4, 2, 6, 0]
#     ]
#     tspApproximation(graph)